Issues:
None

Conclusions:
Overall my major issues was with correctly stepping back up the tree once a solution had been found. My overall goal was to create code that was flexible enough to determine if the root domain had been exhausted, a child domain had been exhausted, or a solution had been found. To achieve that I flagged the backtrack state, methodized the key components, and checked for the values that indicated what state had triggered the backtrack. I think it is a little clunky in this form but creates good results.


Approach 2 Plan:
To write approach 2, I was going to encode values in the 1D array as follow: 
-1 is a space with a Queen
0 is a space that has not been restricted by Queen placements
All following numbers are parsed bitwise to indicate which row's Queen has blocked the space.
For example, a 3 indicated that the space has been blocked by both the Queen in row 0 and row 1.
This allows backtracking to successfully undo assignments, though at a cost due to the en/decoding.
